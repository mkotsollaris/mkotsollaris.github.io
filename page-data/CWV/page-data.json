{"componentChunkName":"component---src-templates-blog-post-js","path":"/CWV/","result":{"data":{"site":{"siteMetadata":{"title":"Menelaos Kotsollaris","author":"Menelaos Kotsollaris"}},"markdownRemark":{"id":"fb0cacdb-70ec-5519-9cc7-4960463906ec","excerpt":"It’s been almost six months since I joined Realtor.com, and the journey has been fascinating. Being in such a consumer-focused company, everything revolves…","html":"<p>It’s been almost six months since I joined Realtor.com, and the journey has been fascinating. Being in such a consumer-focused company, everything revolves around performance, optimization, and SEO. I thought of putting together a collection of strategies for optimizing Core Web Vitals (CWV) and creating crawler-friendly web pages.</p>\n<h2>Introduction to Core Web Vitals</h2>\n<p>Core web vitals are a set of performance indicators that are used to measure the performance of a web page. Google and other search engines use these to determine the quality of a web page. As of now, we have 3 core web vitals:</p>\n<ul>\n<li><strong>Largest Contentful Paint (LCP)</strong></li>\n</ul>\n<blockquote>\n<p>This is the time it takes to render the first chunk of content on the page.</p>\n</blockquote>\n<ul>\n<li><strong>First Input Delay (FID)</strong></li>\n</ul>\n<blockquote>\n<p>This is the time it takes for the user to type in the first character of the page.</p>\n</blockquote>\n<ul>\n<li><strong>Commutative Layout Shift (CLS)</strong></li>\n</ul>\n<blockquote>\n<p>This CWV measures the amount of pixels that are shifted from their original position.</p>\n</blockquote>\n<p>While there are many other web vitals, the Google Engine weights these core web vitals in a bigger magnitude than the others. As such, I decided to create a collection of strategies for optimizing these core web vitals.</p>\n<h2>Largest Contentful Paint (LCP)</h2>\n<p>Largest Contentful Paint is trying to measure the time it takes to render the first chunk of content on the page. This is done by measuring the time it takes to render the first chunk of content on the page. </p>\n<p>The most important factor which affects LCP is the rendering strategy by the webserver. Whether the server is rendered on the server (SSR), whether the page is statically exported (SSG) or the client renders it (CSR), the LCP will be different for each of these strategies. Have a look at the following image presented by Kara Erickson in <a href=\"https://www.youtube.com/watch?v=Nl4OwNhh2QI&#x26;t=760s\">Vercel Conf 2021</a>:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d8c9448b8b2382a996739e1d967e2844/1165a/vercel_SSG_SSR_CSR.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 85.52971576227391%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACmUlEQVQ4y4VTaW/aQBD1///af1ClIpcaqkKl5kA10MQmiWibABGBBMJtDCa218fa8Dq7xBRydaXHemdn3s7MGxTQ4jxGb+QgiubiCHPqIY6X34vF4l0kPslSxM/MDtDu2XA9DoeF6A5dhPTI/9Y66QahyziMiQfT8omQg3kR5vOl43w+l4jjWCKKIrmvZ7eRoe/7GBkGut0uBv0emGtjOpmg3+9jOp1C3HueB8bYBqrVKizLelmy67qYEIHtOGjdFGA8aHBdhsFgIAmfl5QszrnM9NUePtVG4FgQXuvVW3170cPEwB0bnLKVTk+XMfUxUZ7THs9fKr86i6hForITwnu04Y2G/zDoY9wZwnL4apRsN3yb8AmScGQy+MzHIgwQkwAxCbEIPDiPDH2DSSIxBS6L3m3HqmTr0aUZDKisCKEANTyihk9nDmXG4PkcYRiS4p7chRidTge2bUuSnuGhO2LkH0ARChvGSKomxsMXoAxdUr3RaKJe0dC+vYBFitdqNdTrdUk0Ho+lTczo7KELh8ZOaKAEQSBfFYTPEQYhbPMOM6NG51D6JZC9n83kLHKPIRDZE5dimqacQ7GvY0Kv929vYY4nsGxXns01P5GhiJOxCciutFotNJv3KP++QfPuHt3OA64qdZT/1FG/ukKTymzQv6JRqeC+2USr3YaIeQtKtVpB4fQSxz9K0M/L0EtlnKjnODw5w6Wm45eu4SKfR7mYx0/1FBrdi5hKZYnr6+sNKKWSjuNcAd++qzg8ziNfOJUoFM+g6foSJfFYCSrZ1cIZdLKpqopisSi/NU1bQclkMtjd3cX2dgqpVAoHB5+xv7+HnZ0dpNNpZLNZCJ9MJouvX/aw/fEDspk0trY+kd8+crkcjo6OVvgLnyn976nybTIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"LCP - SSG vs SSR vs CSR\"\n        title=\"LCP - SSG vs SSR vs CSR\"\n        src=\"/static/d8c9448b8b2382a996739e1d967e2844/b9e4f/vercel_SSG_SSR_CSR.png\"\n        srcset=\"/static/d8c9448b8b2382a996739e1d967e2844/cf440/vercel_SSG_SSR_CSR.png 148w,\n/static/d8c9448b8b2382a996739e1d967e2844/d2d38/vercel_SSG_SSR_CSR.png 295w,\n/static/d8c9448b8b2382a996739e1d967e2844/b9e4f/vercel_SSG_SSR_CSR.png 590w,\n/static/d8c9448b8b2382a996739e1d967e2844/f9b6a/vercel_SSG_SSR_CSR.png 885w,\n/static/d8c9448b8b2382a996739e1d967e2844/2d849/vercel_SSG_SSR_CSR.png 1180w,\n/static/d8c9448b8b2382a996739e1d967e2844/1165a/vercel_SSG_SSR_CSR.png 1548w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Noticeably enough, SSG is the most performant strategy when considering LCP. When a page is statically exported, All it takes for a page to be rendered is requesting the page from the server, which normally would take under <code class=\"language-text\">100 milliseconds</code>.</p>\n<p>In comparison, SSR and CSR (worst performing LCP strategy) have a much large difference in performance. These approaches require the server to render the page on the server and the client to run further computations that would further delay the page rendering. I would always recommend that whenever SSG is an option, to always try and use it.</p>\n<p>There are other concepts, like TTFB (time-to-first-byte), but I will address those in a follow-up post.</p>\n<h2>First Input Delay (FID)</h2>\n<p>First Input Delay is trying to measure the time it takes for the user to type in the first character of the page. A noticeable FID issue occurs when a user is trying to interact with an element of the web page (button, input, etc.) but the page is unresponsive. This is due to the main thread being occupied by other JavaScript tasks.</p>\n<blockquote>\n<p>The more JavaScript you are running, the higher the chance of bad score for FID.</p>\n</blockquote>\n<p>The above statement might quite sound outragous at first. After all, frontend engineering is all about JavaScript. The above statement suggests that we reduce the amount of JavaScript on the main thread 🤯. There are mainly 3 ways of improving FID: </p>\n<blockquote>\n<ol>\n<li>Replacing JavaScript with CSS</li>\n<li>Using (the correct) DOM API lifecycle methods</li>\n<li>Running JavaScript on a background thread</li>\n</ol>\n</blockquote>\n<h3>Replacing JavaScript with CSS</h3>\n<p>CSS is a truly amazing language! Diving deep into CSS, we can almost re-write a whole lot JavaScript code just with CSS. The power of CSS is that it’s by default optimized for the browser. This means that the browser will execute the code in the most efficient way possible. While CSS is considered (by many) quite of a more <em>boring</em> language that developers use at the end of their tasks, it’s truly sophisticated in its nature and quite underated for its capacities. <a href=\"https://css-for-js.dev/\">CSS for JS</a> is an excellent course that has a lot of great content and examples, in case you want to drill into CSS!</p>\n<h3>Using (the correct) DOM API lifecycle methods</h3>\n<p>The DOM API has a lot of methods that can be used to manipulate the DOM. These methods are called lifecycle methods. These methods are called when the DOM is being manipulated. For example, when a new element is being added to the DOM, the <code class=\"language-text\">onMount</code> method is called. We could use such methods that hook into DOM lifecycle events:</p>\n<ul>\n<li>\n<p>Rather than using scrollEvent (which triggers every single time the page is scrolled), we can use the the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\">IntersectionObserver API</a>. This API is a great way to detect when the user is scrolling the page. An example use-case would be the following:</p>\n<blockquote>\n<p>When user scrolls the page, we want the navigation bacome sticky at the top of the page, and add a small shadow to the navigation bar\nThis can be achieved by both IntersactionObserver and scrollEvent. However, IntersectionObserver is more performant, as it runs on the background thread, resulting to much fewer method triggers as opposed to scrollEvent.</p>\n</blockquote>\n</li>\n</ul>\n<p>Here’s a live example of how to use <a href=\"https://codepen.io/hey-nick/pen/mLpmMV\">IntersectionObserver to create a sticky navigation bar</a></p>\n<p>The Intersection Observer is just one of the lifecycle events that can be used to hook into DOM events. The other many other lifecycle events that can be used, such as the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\">MutationObserver</a>, the <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\">PerformanceObserver</a>, and so on. I highly suggest any JavaScript engineer to do a deep dive into the DOM API and learn about all the lifecycle events that can be used!</p>\n<h3>Running JavaScript on a background thread</h3>\n<!-- ![Impact Fraction]()\n![Alt](/path/to/img.jpg “image title”)\n[hello!](~./images/adam-solomon-hello.jpg~ \"adam solomon's hello”) -->\n<figure>\n  <img src=\"/7b7701ae296ae8113bc0ac75f1461a0a/my-precious-thread.gif\" alt=\"precious Main Thread\">\n  <figcaption>My precious Main Thread!</figcaption>\n</figure>\n<p>Our thread is precious! After all, we have just one thread per browser tab, and if we don’t use it correctly, it will lead to a devastating user-experience. We need to make sure that we utilize our thread as little as possible and only when we need it. I generally like the main thread to be occupied with render-critical tasks, and the background thread to be occupied with non-render-critical tasks.</p>\n<p>Examples of render-critical tasks:</p>\n<ul>\n<li>Rendering the page</li>\n<li>Binding data to the DOM</li>\n<li>Executing a callback function used for user interaction</li>\n</ul>\n<p>Examples on non-render critical tasks:</p>\n<ul>\n<li>Fetching data from the server</li>\n<li>Deferring non-critical CSS</li>\n</ul>\n<p>Fortunately, there are a lot of ways to do this. One of the most common ways is to use <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\">Web Workers</a>. A Web Worker is a JavaScript thread that runs in the background. It’s a great way to run a task that doesn’t need to be rendered on the main thread. By deferring the execution on the background thread, we can avoid overloading the main thread.</p>\n<h2>Commutative Layout Shift (CLS)</h2>\n<p>Commutative Layout Shift is a CWV that measures the number of pixels that are shifted from their original position. CLS is derived from the following formula:</p>\n<blockquote>\n<p> <strong>CLS = (Number of Pixels Shifted) / (Total Number of Pixels)</strong></p>\n</blockquote>\n<ul>\n<li>impact fraction: measures how unstable elements impact the viewport area between two frames. We can have a look at the following example:</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/502d182b4d9059c60e87a04649fbb3b3/44231/CLS_impact_fraction.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 46%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABpklEQVQoz3VRuW7CQBDlB0OTHpr8BBQ08BlUiYREhRQRcQlkYsUgAnbAILCxuIogbhTu82VnuFKEkWaPt7Nv5s3YcDa/3w+73Q6Hw8F7NBplPPDyjEf7A56cTt5fQyHGx+Mx+3Q6xWw2w2q1Ytw2n8/5kkwmEYvFEIlEkEqloOs6B5TVAsaDAebi089kAl1VYRgmstksNE1jVwXW7XZPhIvFggkpIJPJXL1WrXJAo1bj9/3hAByPqIlEvX6fK9vtdthsNliv19jv9ydCWgiQZRmSJHF1iqKgUqlwgCoSSckU3tMyysUStFwOw+EI/9lRJGRCqoDK7nQ6aLVaaLfbLKUkqskrGUEo4UNWoH7mURAJLv26S0iyLcu6PtAH0zSx3W4FoYJ4JC4qT0MraKgUv7AROPWenAZC+3K5vEmmi2EYnIGM+mPV63wu5vMw9TLadQvfzSaqpRLHD0QfB2JYvV4PfXEejUY3QspCcskuzSXZZE1BctZzGlKjwcO4K/lSVSAQgMvlgs/ng9vtRiKRYDwYDDLu9Xrh8XgQDr8xfhBTp79/newXNuuJQmRpyqoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Impact Fraction\"\n        title=\"Impact Fraction\"\n        src=\"/static/502d182b4d9059c60e87a04649fbb3b3/b9e4f/CLS_impact_fraction.png\"\n        srcset=\"/static/502d182b4d9059c60e87a04649fbb3b3/cf440/CLS_impact_fraction.png 148w,\n/static/502d182b4d9059c60e87a04649fbb3b3/d2d38/CLS_impact_fraction.png 295w,\n/static/502d182b4d9059c60e87a04649fbb3b3/b9e4f/CLS_impact_fraction.png 590w,\n/static/502d182b4d9059c60e87a04649fbb3b3/f9b6a/CLS_impact_fraction.png 885w,\n/static/502d182b4d9059c60e87a04649fbb3b3/2d849/CLS_impact_fraction.png 1180w,\n/static/502d182b4d9059c60e87a04649fbb3b3/44231/CLS_impact_fraction.png 2100w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>In the example above, the initial viewport is <code class=\"language-text\">330 pixels</code> but the second frame is <code class=\"language-text\">530 pixels</code> after the first frame transition. The impact fraction is <code class=\"language-text\">0.6</code>. Note that the unit of measurement is a ratio of pixels.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/30c634ecf6871e16f8a7e5d9b727624d/3e10c/CLS_distance_fraction.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.91375291375291%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABpUlEQVQoz51Rf3OaQBTk+3+fNESIJALXSP8RBI0BPFB+WIfqoC0qApu7S5wx7XTayc68ee/u3u3bvZOKKMUqSLD7sUaZZyhXK2wiiiQIwFFVFcqyRFEU2G632Gw2Ivb7vQh+djwecYF0OgFFXgPlDmg6sdmcz6CTiah934dhGDBNE5ZlQdd1EEIwGo1g2zYcx8F8PkeapmKA9JPxrKJfQEjRbneC5HyoEM+eRZ3nOSilWK/XyLIMcRwjSRKcmJK2bXFmw+u6xuFwQNM0kL6nNSK/eiNqO3CNJ2aTTqfo3m3wxstFTsLJeM2t8vU1JGtogZgET+QJxCBwxx6oH8BnVi5kE2Z/sVgIywF7W56XyyVc1xU2ObquEyGpvXv0VQ3KnQr55g5qrw93ZCP0PKGQN/0L1z2SqRPwIMZXkYfDb4gCrtB+s/w++frS9fr3LHFl2v0Dbr/IeHwYQFX60LVHvIydPwj/Fh8Ie7KC2xsZCssyy/rARPg8Q+B8JPxfSD32hkIVs6uwWtMGSNgHzD5LGLIPoN4Uoe0wVWOEYxfZywzxxPsU4SvIcTo62UrFlgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Distance Fraction\"\n        title=\"Distance Fraction\"\n        src=\"/static/30c634ecf6871e16f8a7e5d9b727624d/b9e4f/CLS_distance_fraction.png\"\n        srcset=\"/static/30c634ecf6871e16f8a7e5d9b727624d/cf440/CLS_distance_fraction.png 148w,\n/static/30c634ecf6871e16f8a7e5d9b727624d/d2d38/CLS_distance_fraction.png 295w,\n/static/30c634ecf6871e16f8a7e5d9b727624d/b9e4f/CLS_distance_fraction.png 590w,\n/static/30c634ecf6871e16f8a7e5d9b727624d/f9b6a/CLS_distance_fraction.png 885w,\n/static/30c634ecf6871e16f8a7e5d9b727624d/2d849/CLS_distance_fraction.png 1180w,\n/static/30c634ecf6871e16f8a7e5d9b727624d/3e10c/CLS_distance_fraction.png 1716w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<ul>\n<li>distance fraction: measures the distance that unstable elements have moved, relative to the viewport.</li>\n</ul>\n<p>Since 530 (total viewport) - 330 (initial viewport) = 200, the distance fraction is 200 divided by the total viewport (530) = 0.37.</p>\n<p>From the following computations, we compute CLS</p>\n<blockquote>\n<p><strong>CLS = IF * DF = 0.37 * 0.6 = 0.22</strong></p>\n</blockquote>\n<p>Note that you don’t have to run these computations yourself. Chrome already computes these by default; you can open the chrome web vitals panel by going in chrome dev-tools and hitting <code class=\"language-text\">cmd + shift + P</code>. A challenge that I am actively investigating is how to compute CLS in a headless pattern, through unit tests. In a realistic scenario, we want to make sure that we don’t ship pages that have CLS issues. While there are tools (Sentry, NewRelic, etc.) that report CLS on the page, it’s not always easy to find the culprit. That’s because CLS occurs on page/component transitions.</p>\n<p>One idea I am actively testing is utilizing the <a href=\"https://web.dev/cls/#measure-cls-in-javascript\">PerformanceObserver</a> in combination with a <a href=\"https://netflix.github.io/chaosmonkey/\">chaos-monkey</a>/<a href=\"https://github.com/marak/Faker.js/\">faker</a> tool to measure CLS in randomly generated scenarios. This would work like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">1. Performance Observer is Active\n2. render the component and keep updating it with random props (chaos monkey)\n3. Notice whether CLS &gt; 0</code></pre></div>\n<p>A tool along these lines might have the potential to help us with re-assuring that we ship components without any CLS issues. This sounds like a reasonable way to test CLS, and I post an update once I have a proof of concept!</p>\n<h2>Conclusion</h2>\n<p>This post iterated among the 3 Core Web Vitals (LCP, FID and CLS) and created a collection of strategies for optimizing them. I hope that this post can help you in your journey to optimizing your web page. </p>\n<p>If performance and JavaScript optimization sounds fun to you, my team in <a href=\"https://www.realtor.com/\">Realtor.com</a> is always looking for new ways to optimize our user experience, and we have a bunch of exciting projects! Let’s get in touch!</p>","frontmatter":{"title":"Performant Optimization Strategies for Core Web Vitals (CWV)","date":"January 01, 2022","description":"Strategies for optimizing Core Web Vitals and creating crawler-friendly web pages."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/CWV/","previous":{"fields":{"slug":"/polymorphic-feature-flags/"},"frontmatter":{"title":"Polymorphic feature flags - A pattern for technical debt avoidance"}},"next":null}}}