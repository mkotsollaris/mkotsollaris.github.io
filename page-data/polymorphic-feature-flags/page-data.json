{"componentChunkName":"component---src-templates-blog-post-js","path":"/polymorphic-feature-flags/","result":{"data":{"site":{"siteMetadata":{"title":"Menelaos Kotsollaris","author":"Menelaos Kotsollaris"}},"markdownRemark":{"id":"d1fea263-8d6b-538b-9700-47293e1181ce","excerpt":"While working at a previous project, we were aiming to continuously ship in production, while following a trunk-based methodology. Feature flags are great in‚Ä¶","html":"<p>While working at a previous project, we were aiming to continuously ship in production, while following a <a href=\"https://trunkbaseddevelopment.com/\">trunk-based methodology</a>. <a href='https://martinfowler.com/articles/feature-toggles.html' target='blank'>Feature flags</a> are great in offerring such capabilities. We would use Optimizely to wrap-around our features and then we would ship to production, allowing our project managers to toggle features. The code would be looking something along these lines:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if(FEATURE.enabled) {\n    return &lt;FeatureA/&gt;\n} else {\n    return &lt;DefaultFeature/&gt;\n}</code></pre></div>\n<p>The team loved it, and hence we continued adding as many feature flags as possible, to help our project managers ship more features on-demand. However, not everything was perfect üëá.</p>\n<h2>The problem</h2>\n<p>As more features got shipped to production, we suddenly had <strong>a lot</strong> of code that needs to be maintained in this branched codebase. One way to improve code maintainability would be to remove non-used feature flags, but that requires further maintainance and discipline from the team. So the question arises as to whether there is a better technique methodology to recycling feature flags.</p>\n<h2>Enter polymorphic feature flags</h2>\n<p>We could utilize <a href='https://stackify.com/oop-concept-polymorphism/' target='blank'>Polymorphism</a> to avoid conditional code by creating abstractions (<a href='https://stackoverflow.com/questions/2697783/what-does-program-to-interfaces-not-implementations-mean' target='blank'>aka <strong>programming to interface</strong></a>) rather that writting to implementation. Here‚Äôs an example of how that might look like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># traditional feature flag\nif(FEATURE.enabled) {\n    return FeatureA()\n} else {\n    return Default()\n}</code></pre></div>\n<p>with polymorphism:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"># polymorphic pattern\n\nfunction AbsractFeature(f) {\n    return (enabled) =&gt; {\n        f(enabled); \n    };\n}\n\nAbsractFeature(FeatureA);\nAbsractFeature(DefaultFeature);\n\nFeatureA = enabled =&gt; { if(enabled) console.log(&#39;Feature A Implementation!&#39;)}\nDefaultFeature = enabled =&gt; { if(enabled) console.log(&#39;Default Implementation!&#39;)}</code></pre></div>\n<p>Utilizing the <a href=\"https://en.wikipedia.org/wiki/Higher-order_function\" target='_blank'>higher-order-function</a> methodology, we are able to transform the code in a more declarative pattern.</p>\n<h2>So what?</h2>\n<p>The code is transformed to a more declarative version, but why is that better than before? Here‚Äôs a couple of reasons why this polymorphic style is great:</p>\n<ol>\n<li>Extensibility: Easily add a new feature without adding an <code class=\"language-text\">if-else</code> statement</li>\n<li>Traceability: features can be easily traced throughout the code with no spaghetti-like statements</li>\n<li>Removal: At some point, feature flags will need to be removed from the codebase. The polymorphic pattern makes it extremelly easy to remove unused features.</li>\n</ol>\n<h2>What about not using any line of code? Is it possible?</h2>\n<p>At Facet, we developed a <a href='https://github.com/facet-tech/agent-java' target='blank'>facet-java-agent</a> which does exactly that: every <em>method and endpoint</em> of your system contains a flag which allows toggling. What we noticed is that while developers enjoy the flexibility of the tool and the ease of maintainance, they still prefer in-code declaration. In my experience demoing and talking to people, this is what people say:</p>\n<blockquote>\n<p>Since I am already developing a feature, adding a declaration to it is not hard and makes sense.</p>\n</blockquote>\n<p>The majority of the developers prefer <em>reliability</em> and <em>declarability</em> over ‚Äúframework-magic‚Äù.</p>\n<h2>Summary</h2>\n<p>This polymorhic paradigm aims to make feature declaration extremelly sructured, in order for ease of flag removal. By following this pattern, there‚Äôs an aspiration of even automatically cycling feature flags through CI. For instance, it would be quite straightforward to implement a CI task that removes inactive flags in our codebase. There are various companies working on this domain, including <a href='https://github.com/marketplace/actions/launchdarkly-code-references' target='blank'>LaunchDarkly</a>, <a href='https://github.blog/2021-04-27-ship-code-faster-safer-feature-flags/' target='blank'>GitHub</a> and <a href='https://facet.run' target='blank'>Facet</a>.</p>\n<p>The landscape of feature flags and continuous deployment is more vibrant than ever, and it‚Äôs exciting to what the future will look like!</p>","frontmatter":{"title":"Polymorphic feature flags - A pattern for technical debt avoidance","date":"May 05, 2021","description":"Abstractions to maintaining feature flags without obscuring codebases"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/polymorphic-feature-flags/","previous":{"fields":{"slug":"/devweek-sf-2020/"},"frontmatter":{"title":"Micro Frontends for Rapid SaaS Delivery üëæ"}},"next":null}}}